"""
Streamlit Application for Music Analysis
Web interface for analyzing music and converting to notes
"""

import streamlit as st
import os
import sys
import numpy as np
import json
from datetime import datetime
import tempfile

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from src.audio_processor import AudioProcessor
from src.pitch_detector import PitchDetector
from src.note_converter import NoteConverter
from src.visualizer import AudioVisualizer
from src.midi_exporter import MidiExporter
from src.song_comparator import SongComparator
from src.config import OUTPUT_DIR, TEMP_DIR
from src.utils import validate_url, format_time, get_file_size_mb

# Page configuration
st.set_page_config(
    page_title="Music Analyzer",
    page_icon="üéµ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        color: #1E88E5;
        margin-bottom: 1rem;
    }
    .sub-header {
        font-size: 1.2rem;
        text-align: center;
        color: #666;
        margin-bottom: 2rem;
    }
    .stButton>button {
        width: 100%;
        background-color: #1E88E5;
        color: white;
        font-weight: bold;
    }
    .success-box {
        padding: 1rem;
        background-color: #E8F5E9;
        border-radius: 5px;
        border-left: 5px solid #4CAF50;
    }
    .info-box {
        padding: 1rem;
        background-color: #E3F2FD;
        border-radius: 5px;
        border-left: 5px solid #2196F3;
    }
</style>
""", unsafe_allow_html=True)


# Initialize session state
if 'analysis_complete' not in st.session_state:
    st.session_state.analysis_complete = False
if 'results' not in st.session_state:
    st.session_state.results = None


def main():
    """Main application function"""
    
    # Header
    st.markdown('<div class="main-header">üéµ Music Analyzer</div>', unsafe_allow_html=True)
    st.markdown(
        '<div class="sub-header">Convert audio from URLs into musical notes with beautiful visualizations</div>',
        unsafe_allow_html=True
    )
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Settings")
        
        # Pitch detection method
        pitch_method = st.selectbox(
            "Pitch Detection Method",
            options=['crepe', 'librosa', 'aubio'],
            help="CREPE is most accurate but slower. Librosa is faster but less accurate."
        )
        
        # Post-processing options
        st.subheader("Post-Processing")
        smooth_pitch = st.checkbox("Smooth pitch contour", value=True)
        remove_outliers = st.checkbox("Remove outliers", value=True)
        
        # Visualization options
        st.subheader("Visualizations")
        show_waveform = st.checkbox("Show waveform", value=True)
        show_spectrogram = st.checkbox("Show spectrogram", value=True)
        show_chromagram = st.checkbox("Show chromagram", value=False)
        
        # Export options
        st.subheader("Export")
        export_midi = st.checkbox("Export to MIDI", value=True)
        export_json = st.checkbox("Export to JSON", value=True)
        
        st.markdown("---")
        st.markdown("### About")
        st.info("""
        This app uses advanced pitch detection algorithms to analyze music and convert it into musical notes.
        
        **Features:**
        - Multiple pitch detection methods
        - Interactive visualizations
        - MIDI export
        - Note statistics
        """)
    
    # Main content
    tab1, tab2, tab3 = st.tabs(["üì• Input", "üìä Results", "üîç Compare Songs"])
    
    with tab1:
        st.header("Input Audio")
        
        # Input method selection
        input_method = st.radio(
            "Choose input method:",
            options=["URL", "File Upload"],
            horizontal=True
        )
        
        audio_path = None
        
        if input_method == "URL":
            st.subheader("üåê Enter Audio URL")
            url = st.text_input(
                "Enter YouTube URL or direct audio file URL",
                placeholder="https://www.youtube.com/watch?v=..."
            )
            
            if st.button("üîΩ Download and Analyze", key="download_btn"):
                if not url:
                    st.error("Please enter a URL")
                elif not validate_url(url):
                    st.error("Invalid URL format")
                else:
                    analyze_audio(url, pitch_method, smooth_pitch, remove_outliers,
                                show_waveform, show_spectrogram, show_chromagram,
                                export_midi, export_json, input_type='url')
        
        else:  # File Upload
            st.subheader("üìÅ Upload Audio File")
            uploaded_file = st.file_uploader(
                "Choose an audio file",
                type=['mp3', 'wav', 'flac', 'ogg', 'm4a'],
                help="Supported formats: MP3, WAV, FLAC, OGG, M4A"
            )
            
            if uploaded_file is not None:
                # Save uploaded file temporarily
                with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(uploaded_file.name)[1]) as tmp_file:
                    tmp_file.write(uploaded_file.getvalue())
                    audio_path = tmp_file.name
                
                st.success(f"‚úÖ File uploaded: {uploaded_file.name} ({get_file_size_mb(audio_path):.2f} MB)")
                
                if st.button("üéµ Analyze Audio", key="analyze_btn"):
                    analyze_audio(audio_path, pitch_method, smooth_pitch, remove_outliers,
                                show_waveform, show_spectrogram, show_chromagram,
                                export_midi, export_json, input_type='file')
    
    with tab2:
        if st.session_state.analysis_complete and st.session_state.results:
            display_results(st.session_state.results)
        else:
            st.info("üëà Please input audio from the Input tab to see results here.")


def analyze_audio(source, pitch_method, smooth_pitch, remove_outliers,
                  show_waveform, show_spectrogram, show_chromagram,
                  export_midi, export_json, input_type='url'):
    """
    Analyze audio and store results
    
    Args:
        source: URL or file path
        pitch_method: Pitch detection method
        smooth_pitch: Whether to smooth pitch
        remove_outliers: Whether to remove outliers
        show_waveform: Whether to show waveform
        show_spectrogram: Whether to show spectrogram
        show_chromagram: Whether to show chromagram
        export_midi: Whether to export MIDI
        export_json: Whether to export JSON
        input_type: 'url' or 'file'
    """
    
    with st.spinner("üéµ Analyzing audio... This may take a minute..."):
        try:
            # Initialize processors
            audio_processor = AudioProcessor()
            pitch_detector = PitchDetector()
            note_converter = NoteConverter()
            visualizer = AudioVisualizer()
            midi_exporter = MidiExporter()
            
            # Progress tracking
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            # Step 1: Load audio
            status_text.text("Loading audio...")
            progress_bar.progress(10)
            
            if input_type == 'url':
                audio_data, sr, audio_path = audio_processor.process_from_url(source)
            else:
                audio_data, sr = audio_processor.process_from_file(source)
                audio_path = source
            
            # Normalize and trim
            audio_data = audio_processor.normalize_audio(audio_data)
            audio_data = audio_processor.trim_silence(audio_data)
            
            # Step 2: Detect pitch
            status_text.text(f"Detecting pitch using {pitch_method}...")
            progress_bar.progress(30)
            
            times, frequencies, confidences = pitch_detector.detect_pitch(
                audio_data, method=pitch_method
            )
            
            # Post-process
            if smooth_pitch or remove_outliers:
                frequencies = pitch_detector.post_process_pitch(
                    frequencies, confidences,
                    smooth=smooth_pitch,
                    remove_outliers_flag=remove_outliers
                )
            
            # Step 3: Convert to notes
            status_text.text("Converting to musical notes...")
            progress_bar.progress(50)
            
            notes = note_converter.frequencies_to_notes(frequencies, times)
            note_segments = note_converter.get_note_segments(frequencies, times)
            note_stats = note_converter.get_note_statistics(frequencies, times)
            piano_roll = note_converter.create_piano_roll_data(frequencies, times)
            
            # Step 4: Create visualizations
            status_text.text("Creating visualizations...")
            progress_bar.progress(70)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_prefix = os.path.join(OUTPUT_DIR, f"analysis_{timestamp}")
            
            visualizations = {}
            
            # Dashboard
            dashboard_path = f"{output_prefix}_dashboard.png"
            visualizer.create_summary_dashboard(
                audio_data, sr, times, frequencies, confidences,
                notes, note_stats, output_path=dashboard_path
            )
            visualizations['dashboard'] = dashboard_path
            
            # Pitch plot
            pitch_path = f"{output_prefix}_pitch.png"
            visualizer.plot_pitch_over_time(
                times, frequencies, confidences, output_path=pitch_path
            )
            visualizations['pitch'] = pitch_path
            
            # Notes plot
            notes_path = f"{output_prefix}_notes.png"
            visualizer.plot_notes_over_time(notes, output_path=notes_path)
            visualizations['notes'] = notes_path
            
            # Piano roll
            piano_roll_path = f"{output_prefix}_piano_roll.png"
            visualizer.plot_piano_roll(piano_roll, output_path=piano_roll_path)
            visualizations['piano_roll'] = piano_roll_path
            
            # Optional visualizations
            if show_waveform:
                waveform_path = f"{output_prefix}_waveform.png"
                visualizer.plot_waveform(audio_data, sr, output_path=waveform_path)
                visualizations['waveform'] = waveform_path
            
            if show_spectrogram:
                spec_path = f"{output_prefix}_spectrogram.png"
                visualizer.plot_spectrogram(audio_data, sr, output_path=spec_path)
                visualizations['spectrogram'] = spec_path
            
            if show_chromagram:
                chroma_path = f"{output_prefix}_chromagram.png"
                visualizer.plot_chromagram(audio_data, sr, output_path=chroma_path)
                visualizations['chromagram'] = chroma_path
            
            # Note distribution
            note_dist_path = f"{output_prefix}_note_distribution.png"
            visualizer.plot_note_distribution(note_stats, output_path=note_dist_path)
            visualizations['note_distribution'] = note_dist_path
            
            # Step 5: Export
            status_text.text("Exporting results...")
            progress_bar.progress(90)
            
            exports = {}
            
            if export_midi:
                midi_path = f"{output_prefix}.mid"
                midi_exporter.create_midi_from_segments(note_segments, midi_path)
                exports['midi'] = midi_path
            
            if export_json:
                json_path = f"{output_prefix}.json"
                json_data = {
                    'metadata': {
                        'timestamp': timestamp,
                        'pitch_method': pitch_method,
                        'sample_rate': sr,
                        'duration': len(audio_data) / sr
                    },
                    'statistics': note_stats,
                    'notes': notes,
                    'segments': note_segments
                }
                with open(json_path, 'w') as f:
                    json.dump(json_data, f, indent=2)
                exports['json'] = json_path
            
            # Complete
            progress_bar.progress(100)
            status_text.text("‚úÖ Analysis complete!")
            
            # Store results
            st.session_state.results = {
                'audio_path': audio_path,
                'audio_data': audio_data,
                'sr': sr,
                'times': times,
                'frequencies': frequencies,
                'confidences': confidences,
                'notes': notes,
                'note_segments': note_segments,
                'note_stats': note_stats,
                'visualizations': visualizations,
                'exports': exports,
                'pitch_method': pitch_method
            }
            st.session_state.analysis_complete = True
            
            st.success("üéâ Analysis completed successfully! Check the Results tab.")
            st.balloons()
            
        except Exception as e:
            st.error(f"‚ùå Error during analysis: {str(e)}")
            st.exception(e)


def display_results(results):
    """
    Display analysis results
    
    Args:
        results: Dictionary with analysis results
    """
    
    st.header("üìä Analysis Results")
    
    # Audio information
    duration = len(results['audio_data']) / results['sr']
    
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Duration", format_time(duration))
    with col2:
        st.metric("Sample Rate", f"{results['sr']} Hz")
    with col3:
        st.metric("Total Notes", results['note_stats']['total_notes'])
    with col4:
        st.metric("Unique Notes", results['note_stats']['unique_notes'])
    
    # Dashboard
    st.subheader("üìà Analysis Dashboard")
    if 'dashboard' in results['visualizations']:
        st.image(results['visualizations']['dashboard'], use_container_width=True)
    
    # Detailed visualizations
    st.subheader("üéº Detailed Visualizations")
    
    viz_tab1, viz_tab2, viz_tab3, viz_tab4 = st.tabs([
        "Pitch Over Time", "Musical Notes", "Piano Roll", "Note Distribution"
    ])
    
    with viz_tab1:
        if 'pitch' in results['visualizations']:
            st.image(results['visualizations']['pitch'], use_container_width=True)
    
    with viz_tab2:
        if 'notes' in results['visualizations']:
            st.image(results['visualizations']['notes'], use_container_width=True)
    
    with viz_tab3:
        if 'piano_roll' in results['visualizations']:
            st.image(results['visualizations']['piano_roll'], use_container_width=True)
    
    with viz_tab4:
        if 'note_distribution' in results['visualizations']:
            st.image(results['visualizations']['note_distribution'], use_container_width=True)
    
    # Optional visualizations
    if 'waveform' in results['visualizations'] or 'spectrogram' in results['visualizations']:
        st.subheader("üîä Audio Visualizations")
        cols = st.columns(2)
        
        if 'waveform' in results['visualizations']:
            with cols[0]:
                st.image(results['visualizations']['waveform'], use_container_width=True)
        
        if 'spectrogram' in results['visualizations']:
            with cols[1]:
                st.image(results['visualizations']['spectrogram'], use_container_width=True)
    
    # Statistics
    st.subheader("üìä Note Statistics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Most Common Notes:**")
        for note, count in results['note_stats']['most_common'][:10]:
            st.text(f"{note}: {count} times")
    
    with col2:
        st.markdown("**Frequency Statistics:**")
        st.text(f"Average: {results['note_stats']['avg_frequency']:.1f} Hz")
        st.text(f"Octave Range: {results['note_stats']['octave_range']}")
    
    # Export downloads
    if results['exports']:
        st.subheader("üíæ Download Exports")
        cols = st.columns(len(results['exports']))
        
        for i, (export_type, export_path) in enumerate(results['exports'].items()):
            with cols[i]:
                with open(export_path, 'rb') as f:
                    btn_label = f"Download {export_type.upper()}"
                    st.download_button(
                        label=btn_label,
                        data=f,
                        file_name=os.path.basename(export_path),
                        mime='application/octet-stream'
                    )
    
    # Raw data
    with st.expander("üîç View Raw Data"):
        st.json({
            'total_frames': len(results['times']),
            'detected_pitches': len([f for f in results['frequencies'] if f > 0]),
            'pitch_coverage': f"{len([f for f in results['frequencies'] if f > 0]) / len(results['frequencies']) * 100:.1f}%",
            'method': results['pitch_method']
        })



def display_comparison_tab():
    """Display the song comparison interface"""
    st.header("üîç Compare Two Songs")
    st.markdown("""
        Compare your song with an original to see how similar they are!
        
        Upload or select JSON analysis files from both songs to get:
        - **Overall similarity score** with letter grade
        - **Note-by-note comparison** showing which notes match
        - **Timing analysis** showing how accurate your timing is
        - **Missing notes** that you didn't hit
        - **Extra notes** that weren't in the original
        """)
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üìÑ Original Song")
            
            # Option to select from analyzed files
            output_files = []
            if os.path.exists(OUTPUT_DIR):
                output_files = [f for f in os.listdir(OUTPUT_DIR) if f.endswith('_analysis.json')]
            
            original_method = st.radio(
                "Select original song:",
                options=["From analyzed files", "Upload JSON file"],
                key="original_method"
            )
            
            original_json = None
            if original_method == "From analyzed files":
                if output_files:
                    selected_original = st.selectbox(
                        "Choose analyzed song:",
                        options=output_files,
                        key="original_select"
                    )
                    if selected_original:
                        original_json = os.path.join(OUTPUT_DIR, selected_original)
                else:
                    st.warning("No analyzed songs found. Analyze a song first!")
            else:
                uploaded_original = st.file_uploader(
                    "Upload original song JSON",
                    type=['json'],
                    key="original_upload"
                )
                if uploaded_original:
                    # Save temporarily
                    original_json = os.path.join(TEMP_DIR, "original_temp.json")
                    with open(original_json, 'wb') as f:
                        f.write(uploaded_original.getbuffer())
            
            if original_json and os.path.exists(original_json):
                st.success(f"‚úÖ Original loaded: {os.path.basename(original_json)}")
                # Show preview
                with open(original_json, 'r') as f:
                    orig_data = json.load(f)
                    st.info(f"üìä Notes: {len(orig_data.get('notes', []))}")
        
        with col2:
            st.subheader("üé§ Your Song")
            
            comparison_method = st.radio(
                "Select your song:",
                options=["From analyzed files", "Upload JSON file"],
                key="comparison_method"
            )
            
            comparison_json = None
            if comparison_method == "From analyzed files":
                if output_files:
                    selected_comparison = st.selectbox(
                        "Choose analyzed song:",
                        options=output_files,
                        key="comparison_select"
                    )
                    if selected_comparison:
                        comparison_json = os.path.join(OUTPUT_DIR, selected_comparison)
                else:
                    st.warning("No analyzed songs found. Analyze a song first!")
            else:
                uploaded_comparison = st.file_uploader(
                    "Upload your song JSON",
                    type=['json'],
                    key="comparison_upload"
                )
                if uploaded_comparison:
                    # Save temporarily
                    comparison_json = os.path.join(TEMP_DIR, "comparison_temp.json")
                    with open(comparison_json, 'wb') as f:
                        f.write(uploaded_comparison.getbuffer())
            
            if comparison_json and os.path.exists(comparison_json):
                st.success(f"‚úÖ Your song loaded: {os.path.basename(comparison_json)}")
                # Show preview
                with open(comparison_json, 'r') as f:
                    comp_data = json.load(f)
                    st.info(f"üìä Notes: {len(comp_data.get('notes', []))}")
        
        # Comparison settings
        st.markdown("---")
        st.subheader("‚öôÔ∏è Comparison Settings")
        time_tolerance = st.slider(
            "Time tolerance (seconds)",
            min_value=0.1,
            max_value=2.0,
            value=0.5,
            step=0.1,
            help="Notes within this time window will be considered as matching"
        )
        
        # Compare button
        if st.button("üîç Compare Songs", key="compare_btn"):
            if not original_json or not comparison_json:
                st.error("‚ùå Please select both songs to compare")
            elif not os.path.exists(original_json) or not os.path.exists(comparison_json):
                st.error("‚ùå One or both JSON files not found")
            else:
                with st.spinner("Analyzing similarities..."):
                    try:
                        # Create comparator
                        comparator = SongComparator(time_tolerance=time_tolerance)
                        
                        # Compare songs
                        comparison_results = comparator.compare_songs(original_json, comparison_json)
                        
                        # Display results
                        st.success("‚úÖ Comparison complete!")
                        
                        # Overall Score
                        st.markdown("---")
                        st.markdown("## üéØ Overall Score")
                        
                        score = comparison_results['overall_score']
                        col1, col2, col3, col4 = st.columns(4)
                        
                        with col1:
                            st.metric("Overall Similarity", f"{score['overall_similarity_score']}%")
                        with col2:
                            st.metric("Grade", score['grade'])
                        with col3:
                            st.metric("Note Match", f"{score['note_matching_score']}%")
                        with col4:
                            st.metric("Timing", f"{score['timing_accuracy_score']}%")
                        
                        # Progress bar for overall score
                        st.progress(score['overall_similarity_score'] / 100)
                        
                        # Detailed breakdown
                        st.markdown("---")
                        st.markdown("## üìä Detailed Analysis")
                        
                        tab_dist, tab_match, tab_timing = st.tabs(["Note Distribution", "Note Matching", "Timing Analysis"])
                        
                        with tab_dist:
                            dist = comparison_results['note_distribution']
                            
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Original Notes", dist['total_notes_original'])
                            with col2:
                                st.metric("Your Notes", dist['total_notes_comparison'])
                            with col3:
                                st.metric("Common Notes", dist['common_notes_count'])
                            
                            st.markdown("### Common Notes")
                            st.info(", ".join(dist['common_notes']))
                            
                            if dist['notes_only_in_original']:
                                st.markdown("### ‚ùå Missing Notes (in original but not in yours)")
                                st.warning(", ".join(dist['notes_only_in_original']))
                            
                            if dist['notes_only_in_comparison']:
                                st.markdown("### ‚ûï Extra Notes (in yours but not in original)")
                                st.info(", ".join(dist['notes_only_in_comparison']))
                        
                        with tab_match:
                            match = comparison_results['note_matching']
                            
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Matched Notes", match['matching_notes_count'])
                            with col2:
                                st.metric("Match %", f"{match['match_percentage']}%")
                            with col3:
                                st.metric("Unmatched", match['unmatched_original_count'])
                            
                            st.markdown("### Matched Notes Sample")
                            if match['matching_notes']:
                                match_data = []
                                for m in match['matching_notes'][:20]:
                                    match_data.append({
                                        'Note': m['note'],
                                        'Original Time': f"{m['original_time']:.2f}s",
                                        'Your Time': f"{m['comparison_time']:.2f}s",
                                        'Time Diff': f"{m['time_difference']:.3f}s",
                                        'Freq Diff': f"{m['frequency_difference_hz']:.1f}Hz"
                                    })
                                st.dataframe(match_data, use_container_width=True)
                            
                            if match['unmatched_in_original']:
                                st.markdown("### Missing Notes Details")
                                with st.expander("Show missing notes"):
                                    for note in match['unmatched_in_original'][:20]:
                                        st.text(f"‚ùå {note['note']} @ {note['time']:.2f}s")
                        
                        with tab_timing:
                            timing = comparison_results['timing_analysis']
                            
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Avg Time Diff", f"{timing['average_time_difference']:.3f}s")
                            with col2:
                                st.metric("Timing Accuracy", f"{timing['timing_accuracy_percentage']:.1f}%")
                            with col3:
                                st.metric("Max Time Diff", f"{timing['max_time_difference']:.3f}s")
                            
                            st.info(f"""
                            **Timing Statistics:**
                            - Minimum difference: {timing['min_time_difference']:.3f}s
                            - Standard deviation: {timing['std_time_difference']:.3f}s
                            
                            Lower values indicate better timing accuracy!
                            """)
                        
                        # Generate and download report
                        st.markdown("---")
                        st.markdown("## üìÑ Download Report")
                        
                        report = comparator.generate_comparison_report(comparison_results)
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            st.download_button(
                                label="üì• Download Text Report",
                                data=report,
                                file_name=f"comparison_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                                mime="text/plain"
                            )
                        
                        with col2:
                            st.download_button(
                                label="üì• Download JSON Report",
                                data=json.dumps(comparison_results, indent=2),
                                file_name=f"comparison_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                                mime="application/json"
                            )
                        
                        # Show text report in expander
                        with st.expander("üìÑ View Text Report"):
                            st.text(report)
                        
                    except Exception as e:
                        st.error(f"‚ùå Error during comparison: {str(e)}")
                        import traceback
                        st.code(traceback.format_exc())


if __name__ == "__main__":
    main()
